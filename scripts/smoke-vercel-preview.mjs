/** * Hardened smoke test for protected Vercel previews. * - Accepts a preview URL via env (preferred) or falls back to root fetch. * - Sets the Vercel protection-bypass cookie AND sends the header for every test request. * - Tolerates 401/302 flows and logs clean diagnostics. */ const { PREVIEW_URL = '', VERCEL_BYPASS_TOKEN = '', } = process.env; function die(msg, extra) { console.error('❌', msg); if (extra) console.error(extra); process.exit(1); } function log(msg, extra) { console.log('ℹ️', msg); if (extra) console.log(extra); } function mustUrl(s) { try { return new URL(s); } catch { die(Invalid PREVIEW_URL: ${s}); } } async function setBypassCookie(baseUrl) { if (!VERCEL_BYPASS_TOKEN) { die('Missing VERCEL_BYPASS_TOKEN. Add the project’s “Protection Bypass for Automation” value to repo secrets.'); } const u = new URL(baseUrl); // Use a deterministic path to avoid cookie path issues. u.pathname = '/'; u.search = x-vercel-set-bypass-cookie=true&x-vercel-protection-bypass=${encodeURIComponent(VERCEL_BYPASS_TOKEN)}; log('Setting Vercel bypass cookie…', u.toString()); // We send BOTH the query param and the header. const res = await fetch(u.toString(), { redirect: 'manual', headers: { 'x-vercel-protection-bypass': VERCEL_BYPASS_TOKEN }, }); const okStatuses = [200, 204, 302, 307]; if (!okStatuses.includes(res.status)) { const text = await res.text().catch(() => ''); die(Bypass cookie request failed (status ${res.status})., text.slice(0, 600)); } log(Bypass cookie set (status ${res.status}).); } async function tryEndpoint(baseUrl, path) { const u = new URL(baseUrl); u.pathname = path; const res = await fetch(u.toString(), { redirect: 'manual', headers: { 'x-vercel-protection-bypass': VERCEL_BYPASS_TOKEN }, }).catch((e) => ({ ok: false, status: 0, _err: e })); if (!res || !('status' in res)) { die(Fetch failed for ${u.toString()}); } let body = ''; try { body = await res.text(); } catch {} log(GET ${u.pathname} → ${res.status}); return { status: res.status, body }; } async function main() { const base = PREVIEW_URL ? mustUrl(PREVIEW_URL).toString() : null; if (!base) { die('No PREVIEW_URL provided. When you run the workflow, paste the current preview URL in the input.'); } // 1) Set bypass cookie await setBypassCookie(base); // 2) Probe API first (if present), then fallback to root const apiCandidates = ['/api/ping', '/api/ingest']; for (const p of apiCandidates) { const r = await tryEndpoint(base, p); if (r.status >= 200 && r.status < 400) { log(API probe passed on ${p}); console.log('✅ smoke passed.'); process.exit(0); } // 404 is fine—might be a static site; we’ll try root next. if (r.status === 401) { // If we still get 401 after cookie+header, report clearly. die(Still unauthorized on ${p}. Verify the bypass token matches the project and the URL is this project’s preview.); } } // 3) Root page fallback (static sites) const root = await tryEndpoint(base, '/'); if (root.status >= 200 && root.status < 400) { log('Root page probe passed.'); console.log('✅ smoke passed.'); process.exit(0); } die(Root page probe failed (status ${root.status}). First 600 chars:\n${root.body?.slice?.(0,600) ?? ''}); } main().catch((err) => die('Unhandled error', err));
