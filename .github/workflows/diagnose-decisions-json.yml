name: diagnose-decisions-json
on:
  workflow_dispatch:
    inputs:
      pos:
        description: "Zero-based byte/char position from the Reconciler error (e.g., 5837)"
        required: true
        default: "0"

jobs:
  diagnose:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show file size and basic validation
        run: |
          set -euo pipefail
          echo "decisions.json size (bytes):"
          wc -c < decisions.json
          echo
          echo "jq parse check:"
          if jq . decisions.json >/dev/null 2>&1; then
            echo "OK: jq can parse"
          else
            echo "ERROR: jq failed to parse"
            jq . decisions.json || true
          fi

      - name: Print 120-char window around position
        env:
          POS: ${{ github.event.inputs.pos }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import sys, json, os
          pos = int(os.environ["POS"])
          with open("decisions.json","rb") as f:
              b = f.read()
          n = len(b)
          start = max(0, pos-80)
          end   = min(n, pos+80)
          window = b[start:end]
          print(f"File length: {n} bytes")
          print(f"Requested position: {pos}")
          print(f"Window [{start}:{end}] (bytes):")
          print(window)
          try:
              s = window.decode("utf-8")
              print("\nUTF-8 window:")
              print(s)
              print("\nChar codes:")
              print([c for c in window])
          except Exception as e:
              print("\nDecode error:", e)
          PY

      - name: Print 3 lines around offending position (line/col)
        env:
          POS: ${{ github.event.inputs.pos }}
        run: |
          set -euo pipefail
          # Convert to line:col by counting newlines up to POS
          python - <<'PY'
          import os
          pos = int(os.environ["POS"])
          with open("decisions.json","r",encoding="utf-8",errors="replace") as f:
              s = f.read()
          line = s.count("\n",0,pos) + 1
          col  = pos - (s.rfind("\n",0,pos)+1)
          print(f"Approx line: {line}, column: {col}")
          lines = s.splitlines()
          for i in range(max(0,line-2), min(len(lines), line+1)):
              pointer = " " * (col if i==line-1 else 0) + "^"
              print(f"{i+1:6d}: {lines[i]}")
              if i==line-1:
                  print(f"       {pointer}")
          PY
