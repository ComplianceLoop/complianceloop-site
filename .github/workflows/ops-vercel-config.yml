      - name: Upsert environment variables (skip if value empty)
        run: |
          set -euo pipefail
          TEAM_ID='${{ steps.team.outputs.id }}'
          PROJECT_ID='${{ steps.project.outputs.id }}'

          create_payload () {
            NAME="$1"; VALUE="$2"
            jq -n --arg k "$NAME" --arg v "$VALUE" \
              '{type:"plain", key:$k, value:$v, target:["production","preview","development"]}'
          }

          patch_payload () {
            VALUE="$1"
            jq -n --arg v "$VALUE" '{value:$v}'
          }

          upsert () {
            NAME="$1"; VALUE="$2"
            if [ -z "$VALUE" ]; then
              echo "Skipping $NAME (no value)"; return 0
            fi

            # 1) Try to CREATE (will 409 if exists)
            create_payload "$NAME" "$VALUE" > env.create.json
            set +e
            HTTP=$(curl -sS -o create.out -w "%{http_code}" -X POST \
              "https://api.vercel.com/v10/projects/${PROJECT_ID}/env?teamId=${TEAM_ID}" \
              -H "Authorization: Bearer ${VERCEL_TOKEN}" \
              -H "Content-Type: application/json" \
              --data-binary @env.create.json)
            RC=$?
            set -e

            if [ $RC -ne 0 ]; then
              echo "::error::network error creating $NAME"; cat create.out; exit 1
            fi

            if [ "$HTTP" = "200" ] || [ "$HTTP" = "201" ]; then
              echo "Created $NAME"; return 0
            fi

            if [ "$HTTP" != "409" ]; then
              echo "::error::Create $NAME failed (HTTP $HTTP)"; cat create.out; exit 1
            fi

            echo "$NAME exists; updating all existing idsâ€¦"

            # 2) FETCH existing env entries for this key
            ENVS=$(curl -fsSL -H "Authorization: Bearer ${VERCEL_TOKEN}" \
              "https://api.vercel.com/v10/projects/${PROJECT_ID}/env?decrypt=false&teamId=${TEAM_ID}")

            IDS=$(echo "$ENVS" | jq -r --arg k "$NAME" '.envs[] | select(.key==$k) | .id')
            if [ -z "$IDS" ]; then
              echo "::warning::No ids found for $NAME after 409; nothing to patch"; return 0
            fi

            # 3) PATCH each id with just the new value (do not send key/type/target)
            patch_payload "$VALUE" > env.patch.json
            for ID in $IDS; do
              set +e
              HTTP2=$(curl -sS -o patch.out -w "%{http_code}" -X PATCH \
                "https://api.vercel.com/v10/projects/${PROJECT_ID}/env/${ID}?teamId=${TEAM_ID}" \
                -H "Authorization: Bearer ${VERCEL_TOKEN}" \
                -H "Content-Type: application/json" \
                --data-binary @env.patch.json)
              RC2=$?
              set -e

              if [ $RC2 -ne 0 ]; then
                echo "::warning::network error patching $NAME id=$ID"; cat patch.out; continue
              fi

              if [ "$HTTP2" = "200" ] || [ "$HTTP2" = "201" ]; then
                echo "Patched $NAME (id=$ID)"
              else
                echo "::warning::Patch $NAME id=$ID failed (HTTP $HTTP2)"; cat patch.out
              fi
            done
          }

          upsert "R2_PUBLIC_BASE" "${R2_PUBLIC_BASE}"
          upsert "VERCEL_BYPASS_TOKEN" "${VERCEL_BYPASS_TOKEN}"
          # Add any others you actually use:
          # upsert "DATABASE_URL" "${{ secrets.DATABASE_URL }}"
          # upsert "AIRTABLE_API_KEY" "${{ secrets.AIRTABLE_API_KEY }}"
          # upsert "AIRTABLE_BASE_ID" "${{ secrets.AIRTABLE_BASE_ID }}"
          # upsert "AIRTABLE_TABLE" "${{ secrets.AIRTABLE_TABLE }}"
          # upsert "ORIGIN_ALLOWLIST" "${{ vars.ORIGIN_ALLOWLIST }}"
          # upsert "USE_DIRECT_WEBHOOKS" "${{ vars.USE_DIRECT_WEBHOOKS }}"
