name: phase-1-auth-db
on:
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  phase_1:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Add / update files for Phase 1 (Auth + DB base)
        run: |
          set -euo pipefail

          mkdir -p apps/portal/lib
          mkdir -p apps/portal/db
          mkdir -p apps/portal/app/api/auth/send-code
          mkdir -p apps/portal/app/api/auth/verify-code
          mkdir -p apps/portal/scripts

          # --- package.json (full-file replace to add deps/scripts) ---
          cat > apps/portal/package.json <<'EOF'
          {
            "name": "complianceloop-portal",
            "private": true,
            "scripts": {
              "dev": "next dev",
              "build": "next build",
              "start": "next start",
              "lint": "next lint",
              "typecheck": "tsc --noEmit",
              "db:seed": "node --loader ts-node/esm apps/portal/scripts/seed.ts"
            },
            "dependencies": {
              "next": "14.2.5",
              "react": "18.3.1",
              "react-dom": "18.3.1",
              "drizzle-orm": "0.33.0",
              "@neondatabase/serverless": "0.10.1",
              "uuid": "9.0.1",
              "cookie": "0.6.0",
              "resend": "3.5.0"
            },
            "devDependencies": {
              "typescript": "5.4.5",
              "ts-node": "10.9.2",
              "@types/node": "20.11.30"
            }
          }
          EOF

          # --- tsconfig (ensure moduleResolution works) ---
          cat > apps/portal/tsconfig.json <<'EOF'
          {
            "compilerOptions": {
              "target": "ES2022",
              "lib": ["ES2022", "DOM", "DOM.Iterable"],
              "module": "ESNext",
              "moduleResolution": "Bundler",
              "jsx": "preserve",
              "strict": true,
              "allowJs": false,
              "esModuleInterop": true,
              "forceConsistentCasingInFileNames": true,
              "skipLibCheck": true
            },
            "include": ["app", "lib", "db", "scripts", "next-env.d.ts"]
          }
          EOF

          # --- db/schema.ts ---
          cat > apps/portal/db/schema.ts <<'EOF'
          import { pgTable, serial, text, timestamp, integer, boolean } from "drizzle-orm/pg-core";

          export const customers = pgTable("customers", {
            id: serial("id").primaryKey(),
            name: text("name").notNull(),
            email: text("email").notNull(),
            portalSlug: text("portal_slug").notNull().unique(),
            portalSecret: text("portal_secret").notNull(),
            createdAt: timestamp("created_at").defaultNow().notNull()
          });

          export const providers = pgTable("providers", {
            id: serial("id").primaryKey(),
            name: text("name").notNull(),
            email: text("email").notNull(),
            phone: text("phone"),
            serviceArea: text("service_area"),
            availabilitySource: text("availability_source").default("unknown").notNull(),
            weeklyHoursJson: text("weekly_hours_json"),
            maxJobsPerDay: integer("max_jobs_per_day").default(3),
            notificationEmailPrimary: text("notification_email_primary"),
            notificationEmailCc: text("notification_email_cc"),
            techDefaultEmail: text("tech_default_email"),
            rushOptIn: boolean("rush_opt_in").default(false),
            assignmentScore: integer("assignment_score").default(0),
            createdAt: timestamp("created_at").defaultNow().notNull()
          });

          export const providerBlocks = pgTable("provider_blocks", {
            id: serial("id").primaryKey(),
            providerId: integer("provider_id").notNull(),
            startsAt: timestamp("starts_at").notNull(),
            endsAt: timestamp("ends_at").notNull()
          });

          export const jobs = pgTable("jobs", {
            id: serial("id").primaryKey(),
            customerId: integer("customer_id").notNull(),
            providerId: integer("provider_id"),
            title: text("title").notNull(),
            address: text("address"),
            startAt: timestamp("start_at"),
            endAt: timestamp("end_at"),
            status: text("status").default("UPCOMING").notNull(),
            notes: text("notes"),
            technicianName: text("technician_name"),
            technicianEmail: text("technician_email"),
            technicianPhone: text("technician_phone"),
            autoAssigned: boolean("auto_assigned").default(false),
            createdAt: timestamp("created_at").defaultNow().notNull()
          });

          export const jobAssets = pgTable("job_assets", {
            id: serial("id").primaryKey(),
            jobId: integer("job_id").notNull(),
            type: text("type").notNull(),
            r2Key: text("r2_key").notNull(),
            contentType: text("content_type"),
            bytes: integer("bytes").default(0),
            createdAt: timestamp("created_at").defaultNow().notNull()
          });

          export const loginCodes = pgTable("login_codes", {
            id: serial("id").primaryKey(),
            email: text("email").notNull(),
            code: text("code").notNull(),
            expiresAt: timestamp("expires_at").notNull(),
            createdAt: timestamp("created_at").defaultNow().notNull()
          });

          export const sessions = pgTable("sessions", {
            id: serial("id").primaryKey(),
            customerId: integer("customer_id"),
            email: text("email").notNull(),
            token: text("token").notNull(),
            expiresAt: timestamp("expires_at").notNull(),
            createdAt: timestamp("created_at").defaultNow().notNull()
          });

          export const slotHolds = pgTable("slot_holds", {
            id: serial("id").primaryKey(),
            slotKey: text("slot_key").notNull(),
            customerEmail: text("customer_email").notNull(),
            expiresAt: timestamp("expires_at").notNull(),
            createdAt: timestamp("created_at").defaultNow().notNull()
          });
          EOF

          # --- lib/db.ts (Neon + Drizzle) ---
          cat > apps/portal/lib/db.ts <<'EOF'
          import { drizzle } from "drizzle-orm/neon-http";
          import { neon } from "@neondatabase/serverless";

          const url = process.env.DATABASE_URL;
          if (!url) {
            throw new Error("DATABASE_URL is missing. Add it in Vercel → Project → Settings → Environment Variables.");
          }

          const sql = neon(url);
          export const db = drizzle(sql);
          EOF

          # --- lib/auth.ts ---
          cat > apps/portal/lib/auth.ts <<'EOF'
          import { cookies } from "next/headers";
          import { randomUUID } from "crypto";
          import { db } from "./db";
          import { sessions } from "../db/schema";
          import { eq, lt } from "drizzle-orm";

          const SESSION_COOKIE = "cl_session";
          const TTL_MINUTES = Number(process.env.AUTH_SESSION_TTL_MINUTES ?? "1440");

          export async function createSession(email: string, customerId?: number) {
            const token = randomUUID();
            const expires = new Date(Date.now() + TTL_MINUTES * 60 * 1000);
            await db.insert(sessions).values({ email, customerId, token, expiresAt: expires });
            cookies().set(SESSION_COOKIE, token, { httpOnly: true, sameSite: "lax", secure: true, expires });
          }

          export async function getSession() {
            const token = cookies().get(SESSION_COOKIE)?.value;
            if (!token) return null;
            const rows = await db.select().from(sessions).where(eq(sessions.token, token)).limit(1);
            if (rows.length === 0) return null;
            if (rows[0].expiresAt && rows[0].expiresAt < new Date()) return null;
            return rows[0];
          }

          export async function cleanupSessions() {
            await db.delete(sessions).where(lt(sessions.expiresAt, new Date()));
          }
          EOF

          # --- API: send-code ---
          cat > apps/portal/app/api/auth/send-code/route.ts <<'EOF'
          import { db } from "@/app/../lib/db";
          import { loginCodes } from "@/app/../db/schema";
          import { eq } from "drizzle-orm";
          import { Resend } from "resend";

          export const dynamic = "force-dynamic";

          function generateCode(){ return (Math.floor(100000 + Math.random()*900000)).toString(); }

          export async function POST(request: Request) {
            const { email } = await request.json();
            if (!email) return new Response("email required", { status: 400 });

            const code = process.env.VERCEL_ENV !== "production" || process.env.TEST_MODE === "true"
              ? "000000"
              : generateCode();

            const expiresAt = new Date(Date.now() + 10*60*1000);
            // simple upsert per email (one active code)
            await db.delete(loginCodes).where(eq(loginCodes.email, email));
            await db.insert(loginCodes).values({ email, code, expiresAt });

            if (process.env.VERCEL_ENV === "production") {
              const key = process.env.RESEND_API_KEY;
              if (key) {
                const resend = new Resend(key);
                await resend.emails.send({
                  from: "ComplianceLoop <no-reply@complianceloop.com>",
                  to: email,
                  subject: "Your ComplianceLoop sign-in code",
                  text: `Your code is ${code} (valid for 10 minutes).`
                });
              }
            }
            return new Response("ok");
          }
          EOF

          # --- API: verify-code ---
          cat > apps/portal/app/api/auth/verify-code/route.ts <<'EOF'
          import { db } from "@/app/../lib/db";
          import { loginCodes, customers } from "@/app/../db/schema";
          import { and, eq, gt } from "drizzle-orm";
          import { createSession } from "@/app/../lib/auth";

          export const dynamic = "force-dynamic";

          export async function POST(request: Request) {
            const { email, code } = await request.json();
            if (!(email && code)) return new Response("bad request", { status: 400 });

            const rows = await db.select().from(loginCodes).where(
              and(eq(loginCodes.email, email), eq(loginCodes.code, code), gt(loginCodes.expiresAt, new Date()))
            ).limit(1);

            if (rows.length === 0) return new Response("invalid code", { status: 401 });

            // Attach to existing customer if one exists
            const cust = await db.select().from(customers).where(eq(customers.email, email)).limit(1);
            const customerId = cust[0]?.id;

            await createSession(email, customerId);
            // burn code
            await db.delete(loginCodes).where(eq(loginCodes.email, email));

            return new Response("ok");
          }
          EOF

          # --- seed script (node/ts-node) ---
          cat > apps/portal/scripts/seed.ts <<'EOF'
          import { db } from "../lib/db";
          import { customers, jobs } from "../db/schema";

          async function main(){
            const now = new Date();
            const [c] = await db.insert(customers).values({
              name: "Acme Corp",
              email: "ops@example.com",
              portalSlug: "acme",
              portalSecret: "seeded-secret",
            }).returning({ id: customers.id }).catch(()=>[] as any);

            const customerId = c?.id ?? 1;

            await db.insert(jobs).values([
              { customerId, title:"Annual Inspection", address:"123 Main St", startAt:new Date(now.getTime()+86400000), status:"UPCOMING" },
              { customerId, title:"Completed Test", address:"456 Pine Ave", startAt:new Date(now.getTime()-86400000*7), endAt:new Date(now.getTime()-86400000*7+3600000), status:"COMPLETED" }
            ]).catch(()=>{});
          }

          main().then(()=>console.log("seeded")).catch(e=>{ console.error(e); process.exit(1); });
          EOF

      - name: Create PR
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ github.token }}
          branch: feat/phase-1-auth-db
          title: "feat(portal): Phase 1 — auth + DB base (Drizzle + Neon)"
          body: |
            **What’s in here**
            - Drizzle ORM with Neon connection
            - Tables: customers, providers, provider_blocks, jobs, job_assets, login_codes, sessions, slot_holds
            - Passwordless email-code auth: /api/auth/send-code, /api/auth/verify-code
            - Preview-safe mode: returns code 000000 unless in production with RESEND_API_KEY
            - Session cookie helper
            - Seed script

            **Next steps**
            1. Merge this PR
            2. Ensure Vercel env has DATABASE_URL (Neon), and optionally RESEND_API_KEY
            3. Hit /api/auth/send-code with {"email":"you@example.com"} then /api/auth/verify-code with code "000000" on preview to test
          commit-message: "feat(portal): P1 auth + DB base"
          add-paths: |
            apps/portal/package.json
            apps/portal/tsconfig.json
            apps/portal/db/schema.ts
            apps/portal/lib/db.ts
            apps/portal/lib/auth.ts
            apps/portal/app/api/auth/send-code/route.ts
            apps/portal/app/api/auth/verify-code/route.ts
            apps/portal/scripts/seed.ts
