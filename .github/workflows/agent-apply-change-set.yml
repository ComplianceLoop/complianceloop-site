name: Apply Agent Change Set

on:
  workflow_dispatch:
    inputs:
      change_set_json:
        description: "PASTE plain JSON (small/medium change-sets). If provided, it takes priority."
        required: false
        type: string
      change_set_b64_gzip:
        description: "PASTE base64-GZIPPED JSON (best for large change-sets). Used if JSON is empty."
        required: false
        type: string
      change_set_url:
        description: "Fallback: URL to change-set.json (used only if both fields above are empty)."
        required: false
        type: string

concurrency:
  group: apply-agent-changes
  cancel-in-progress: true

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) Inline JSON (highest priority)
      - name: Save inline change set (if provided)
        if: ${{ inputs.change_set_json != '' }}
        uses: actions/github-script@v7
        env:
          CHANGE_SET_JSON: ${{ github.event.inputs.change_set_json }}
        with:
          script: |
            const fs = require('fs');
            const data = process.env.CHANGE_SET_JSON;
            if (!data || data.trim() === '') {
              core.setFailed('Inline change_set_json was empty');
              return;
            }
            fs.writeFileSync('change-set.json', data, { encoding: 'utf8' });

      # 2) Base64-gzipped JSON (next priority)
      - name: Decode base64-gzipped change set (if provided)
        if: ${{ inputs.change_set_json == '' && inputs.change_set_b64_gzip != '' }}
        run: |
          set -euo pipefail
          echo "${{ github.event.inputs.change_set_b64_gzip }}" | base64 -d | gunzip -c > change-set.json

      # 3) URL fallback (last priority)
      - name: Download change set from URL (fallback)
        if: ${{ inputs.change_set_json == '' && inputs.change_set_b64_gzip == '' && inputs.change_set_url != '' }}
        run: |
          set -euo pipefail
          curl -L "${{ github.event.inputs.change_set_url }}" -o change-set.json

      # Guard: ensure we actually have the file
      - name: Ensure change-set.json exists
        run: |
          set -euo pipefail
          test -s change-set.json || { echo "No change-set provided. Paste JSON or base64-gzip, or supply a URL."; exit 1; }

      # Simple, robust schema check (supports deletes)
      - name: Validate change set schema
        run: |
          set -euo pipefail
          jq -e '
            (.files | type=="array") and
            (
              ([.files[] | select(
                  (has("path")) and
                  (
                    (.delete==true) or
                    (has("content") and ((.delete|not) or (.delete==false)))
                  )
                )] | length) == (.files | length)
            )
          ' change-set.json > /dev/null

      - name: Apply files (delete first, then write)
        id: apply
        run: |
          set -euo pipefail

          # 1) Deletes
          jq -r '.files[] | select(.delete==true) | .path' change-set.json | while read -r p; do
            [ -z "$p" ] && continue
            if [ -e "$p" ]; then
              rm -f "$p"
              echo "Deleted $p"
              d="$(dirname "$p")"
              while [ "$d" != "." ] && [ "$d" != "/" ]; do
                rmdir "$d" 2>/dev/null || break
                d="$(dirname "$d")"
              done
            else
              echo "Skip delete (not found): $p"
            fi
          done

          # 2) Writes (supports base64 content per-file)
          jq -r '.files[] | select((.delete|not) or (.delete==false)) | .path' change-set.json | while read -r p; do
            [ -z "$p" ] && continue
            mkdir -p "$(dirname "$p")"
            jq -r --arg p "$p" '
              .files[] | select(.path==$p)
              | if .encoding=="base64" then .content | @base64d else .content end
            ' change-set.json > "$p"
            echo "Wrote $p"
          done

          BRANCH="agent/${GITHUB_RUN_ID}"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Create branch and commit
        run: |
          set -euo pipefail
          git checkout -b "${{ steps.apply.outputs.branch }}"
          git add -A
          git -c user.name="github-actions[bot]" \
              -c user.email="41898282+github-actions[bot]@users.noreply.github.com" \
              commit -m "feat: apply agent change set"
          git push origin "${{ steps.apply.outputs.branch }}"

      - name: Open pull request from agent branch to main
        uses: actions/github-script@v7
        with:
          script: |
            const head = `${{ steps.apply.outputs.branch }}`;
            const base = 'main';
            const title = `Agent build: change set ${context.runId}`;
            const inputs = context.payload.inputs || {};
            const source =
              (inputs.change_set_json && 'inline JSON') ||
              (inputs.change_set_b64_gzip && 'base64-gzip inline') ||
              (inputs.change_set_url || 'unknown');
            const body = `This pull request was created by the agent Committer workflow.\n\nSource: ${source}\n\nPlease review checks and preview.`;
            const { owner, repo } = context.repo;

            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', head: `${owner}:${head}`, base });
            if (prs.length > 0) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prs[0].number, body: `New commit from workflow run ${context.runId}.` });
              core.notice(`PR already exists: ${prs[0].html_url}`);
              return;
            }
            const pr = await github.rest.pulls.create({ owner, repo, head, base, title, body });
            core.notice(`Opened PR: ${pr.data.html_url}`);
